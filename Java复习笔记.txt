B+树索引优化

OOM
出现的情况
1）java.lang.OutOfMemoryError: Java heap space：这种是java堆内存不够，一个原因是真不够，另一个原因
是程序中有死循环；
如果是java堆内存不够的话，可以通过调整JVM下面的配置来解决： 
　　< jvm-arg>-Xms3062m < / jvm-arg> 
　　< jvm-arg>-Xmx3062m < / jvm-arg> 
2）　java.lang.OutOfMemoryError: GC overhead limit exceeded 
　　【解释】：JDK6新增错误类型，当GC为释放很小空间占用大量时间时抛出；一般是因为堆太小，导致异常的原因，
没有足够的内存。 
　　【解决方案】： 
　　1、查看系统是否有使用大内存的代码或死循环； 
　　2、通过添加JVM配置，来限制使用内存： 
　　< jvm-arg>-XX:-UseGCOverheadLimit< /jvm-arg> 
3）　java.lang.OutOfMemoryError: PermGen space：这种是P区内存不够，可通过调整JVM的配置： 
　　< jvm-arg>-XX:MaxPermSize=128m< /jvm-arg> 
　　< jvm-arg>-XXermSize=128m< /jvm-arg> 
　　【注】： 
JVM的Perm区主要用于存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space，这个区域成为
年老代，
GC在主程序运行期间不会对年老区进行清理，默认是64M大小，当程序需要加载的对象比较多时，超过64M就会报这部分
内存溢出了，需要加大内存分配，一般128m足够。 

说说java内存模型吧。
jmm模型一般分为私有区域和共享区域。 共享区域包括
方法区：主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规
范的规定，
当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池
(Runtime Constant Pool）的区域，
它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。
JVM堆：主要用于存放产生的对象实例，也是GC运行的主战场

私有区域
程序计数器：属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器
工作时，
通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要
依赖这个计数器来完成。

虚拟机栈：属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。
每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。
每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程，如下（图有误，应该为栈桢）

本地方法栈：本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无
需关心此区域。


主内存

主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地
变量(也称局部变量)，
当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全
问题。

工作内存

主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，
即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建
属于当前线程的本地变量，
当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问
工作内存，
因此存储在工作内存的数据不存在线程安全问题。

线程间如何和主存通信
而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，
线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，
然后对变量进行操作，操作完成后再将变量写回主内存，



那如何编程测试栈溢出？
不断的new对象，让new的对象多于正常jvm堆的内存
public class HeapOOM {

    static class OOMObject {
    }

    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<OOMObject>();

        while (true) {
            list.add(new OOMObject());
        }
    }
}

熟不熟悉Collection，介绍一下list、set和map？
1、List（有序、可重复）
List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。
因为往list集合里插入或删除数据时，
会伴随着后面数据的移动，所有插入删除数据速度慢。

2、Set（无序、不能重复）
Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。

3、Map（键值对、键唯一、值不唯一）
Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，
对set集合进行遍历，得到相应的值。

map类详解

HashMap 

HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时
，取得数据的顺序是完全随机的。
因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的，他不安
全会引起死循环。或者建的缺失值

Hashtable

Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，
因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效
率较低。

ConcurrentHashMap

线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的
hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。

LinkedHashMap

LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历
的时候会比HashMap慢，有HashMap的全部特性。





hashmap的底层实现
首先算得key得hashcode值，就是哈希函数h = key.hashCode()) ^ (h >>> 16）还有个先判断是不是0的。若是0
直接返回0
不是0返回原hash值和原hash值无符号右移16位的值按位异或的结果。这个做法就是为了让一切小与2的16次方的数都保持
原来的值。

然后跟数组的长度-1做一次“与”运算（&）在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。 
resize方法是用于动态扩容， 一般阈值设定为0.75，开销主要在于重新吧老值传入进去。
同时要重写hashcode方法和equals方法，前面的是为了在数组中定位元素，而equals则是用来在这个索引存在的链表中
精确查找的。
同时equals还具有自反性，传递性，对称性。

HashMap和Hashtable的区别
要的区别有：线程安全性，同步(synchronization)，以及速度。同时一个允许有null值，另一个不允许有null值
1）内部实现使用的数组初始化和扩容方式不同 一个是2的幂16一个是11 扩容后也是2的倍数和2的倍数+1
2）哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。
3）两个遍历方式的内部实现上不同 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用
了Enumeration的方式 。
4）是否提供contains方法HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，
因为contains方法容易让人引起误解。
Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能
相同。

ConcurrentHashMap锁分段技术
    Ha术，首先将数据分成一段shTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问
    HashTable的线程都必须竞争同一把锁，
    那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，
    线程间就不会存在锁竞争，
    从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技一段的存储，然后给每一段数据配
    一把锁，
    当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()
    和containsValue()，
    它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。
    这里“按顺序”是很重要的，
    否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，
    但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁
    ，因为获得锁的顺序是固定的。
    
线程池是什么，为什么要使用线程池，它的直接子类都有什么？如何实现线程池的单例？


面向对象的好处
1、易维护
采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是
非常方便和较低成本的。
2、质量高
在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。
3、效率高
在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的
思考方式，势必提高软件开发的效率和质量。
4、易扩展
由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。


进程间通信方式-----     管道  socket  信号量  共享存储  消息传递


Java事务
脏读：一个事务读取到了另外一个事务没有提交的数据，当一个事务正在访问数据，并且对数据进行了修改，而这种修改还
没有提交到数据库中，另一个事务读取了
不可重复读：在同一事务中，两次读取同一数据，得到内容不同
幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同（区别于不可重复读，这个是记录数，那个是记录内容）
            事务1：查询表中所有记录
                              -------------->事务2：插入一条记录
                              -------------->事务2：调用commit进行提交
            事务1：再次查询表中所有记录
多线程如果设计的不合理的话,很可能就会出现死锁.当两个或者多个线程同事想要去获取共享资源的锁时,但每个线程都要
等其他线程把他们各自的锁给释放,才能继续运行,这就是死锁.出现死锁必须具备以下几点 
* 要有两个或两个以上的线程 
* 至少有两个共享资源的锁 
* 至少存在两个线程各自拥有一个锁 
* 现在这两个线程在等待获取彼此的锁,这就出现死锁了
死锁的解决办法之一就是按顺序分配锁

线程局部变量(ThreadLocal)：其实的功用非常简单，就是为每一个使用该变量的线程都提供一个变量值的副本，是Java
中一种较为特殊的线程绑定机制，
是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。
ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。
synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。
而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了
多个线程对数据的数据共享。
而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。


volatile关键字（用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会
注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写
入的值。）

首先volatile保证可见性
第一：使用volatile关键字会强制将修改的值立即写入主存；
第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到
硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线
程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，
发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。
那么线程1读取到的就是最新的正确的值。
其次volatile不能确保原子性（只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原
子操作）才是原子操作）
例如++运算符，并不是原子的，如果volatile关键字修饰变量，但是它只是让修改了值的变量刷新主存，如果只是读取没
有更改的话并不会刷新，也就是脏读。
保证有序性
volatile关键字禁止指令重排序有两层意思：
1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的
操作可见；在其后面的操作肯定还没有进行；
2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后
面的语句放到其前面执行。

通常来说，使用volatile必须具备以下2个条件才可以同synchronized替换：
1）对变量的写操作不依赖于当前值
2）该变量没有包含在具有其他变量的不变式中

说说CountDownLatch
CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。
例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。
CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。
每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在
闭锁上等待的线程就可以恢复执行任务。
每个进程都应该引用countdown对象才能让计数器减1
应用场景
1实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。
例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那
么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。
2开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行
了。
两个主要的方法CountDownLatch.await()和CountDownLatch.countDown()


乐观锁和悲观锁的区别
悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时
候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
Java中是synchronized实现的悲观锁
乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是
在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的
乐观锁。
Java中是cas来支持的，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程
都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　　　


创建线程在内存模型中分配的位置
Java中Thread的类都是本地方法的，因此其功能都是使用系统内核调用的，那么存放的内存应该就是本地方法栈中


URL的请求流程

Spring
控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法
首先 面向接口编程


单例和多例
1. 什么是单例多例； 2. 如何产生单例多例； 3. 为什么要用单例多例 4. 什么时候用单例，什么时候用多例； 
1. 什么是单例多例: 所谓单例就是所有的请求都用一个对象来处理，比如我们常用的service和dao层的对象通常都是单
例的，
而多例则指每个请求用一个新的对象来处理，比如action; 2. 如何产生单例多例: 在通用的SSH中，单例在spring中是
默认的，
如果要产生多例，则在配置文件的bean中添加scope="prototype"; 3. 为什么用单例多例： 之所以用单例，是因为没
必要每个请求都新建一个对象，
这样子既浪费CPU又浪费内存； 之所以用多例，是为了防止并发问题；即一个请求改变了对象的状态，此时对象又处理另一
个请求，
而之前请求对对象状态的改变导致了对象对另一个请求做了错误的处理； 用单例和多例的标准只有一个： 当对象含有可改
变的状态时（
更精确的说就是在实际应用中该状态会改变），则多例，否则单例； 4. 何时用单例？何时用多例？ 对于struts2来说，
action必须用多例，
因为action本身含有请求参数的值，即可改变的状态； 而对于STRUTS1来说，action则可用单例，
因为请求参数的值是放在actionForm中，而非action中的； 另外要说一下，并不是说service或dao一定是单例，标准
同第3点所讲的，
就曾见过有的service中也包含了可改变的状态，同时执行方法也依赖该状态，但一样用的单例，这样就会出现隐藏的BUG,
而并发的BUG通常很难重现和查找；


JVM 类加载机制详解
JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化

工厂模式创建的对象和new创建的对象有什么区别?
防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中 
工厂可以简化New的过程，让程度更健康


怎么实现Mysql和Redis的数据一致性问题？
mysql的一致性可以通过事务来解决


CAS
CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。


Java线程中断的方法
对于那些阻塞方法(比如 wait() 和 sleep())而言，当另一个线程调用interrupt()中断该线程时，
该线程会从阻塞状态退出并且抛出中断异常。这样，我们就可以捕捉到中断异常，并根据实际情况对该线程从阻塞方法中异
常退出而进行一些处理。



Java垃圾回收机制
根搜索算法：搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找
对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认
为是没有被引用到的节点，即无用的节点。
标记清除算法:
标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回
收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极
为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
标记-整理算法：
但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。
标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。
在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。


类加载器
1）Bootstrap ClassLoader
 
负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类
 
2）Extension ClassLoader
 
负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的j
ar包
 
3）App ClassLoader
 
负责记载classpath中指定的jar包及目录中class
 
4）Custom ClassLoader
 
属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader
加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader
逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是
自顶向下，也就是由上层来逐层尝试加载此类。

==可用于基本类型和引用类型：当用于基本类型时候，是比较值是否相同；当用于引用类型的时候，是比较对象是否相同。


String详解
1.String类初始化后是不可变的(immutable)
String使用private final char value[]来实现字符串的存储，也就是说String对象创建之后，就不能再修改此对象中存储的字符串内容，就是因为如此，才说String类型是不可变的(immutable)。
程序员不能对已有的不可变对象进行修改。我们自己也可以创建不可变对象，只要在接口中不提供修改数据的方法就可以。然而，String类对象确实有编辑字符串的功能，比如replace()。这些编辑功能是通过创建一个新的对象来实现的，而不是对原有对象进行修改。
2.引用变量与对象

A aa;
这个语句声明一个类A的引用变量aa[我们常常称之为句柄]，而对象一般通过new创建。所以aa仅仅是一个引用变量，它不是对象。

3.创建字符串的方式

创建字符串的方式归纳起来有两类：

（1）使用""引号创建字符串;

（2）使用new关键字创建字符串。

结合上面例子，总结如下:

（1）单独使用""引号创建的字符串都是常量,编译期就已经确定存储到String Pool中；

（2）使用new String("")创建的对象会存储到heap中,是运行期新创建的；

new创建字符串时首先查看池中是否有相同值的字符串，如果有，则拷贝一份到堆中，然后返回堆中的地址；如果池中没有，则在堆中创建一份，然后返回堆中的地址（注意，此时不需要从堆中复制到池中，否则，将使得堆中的字符串永远是池中的子集，导致浪费池的空间）！

（3）使用只包含常量的字符串连接符如"aa" + "aa"创建的也是常量,编译期就能确定,已经确定存储到String Pool中这样比较==的话是返回的true

（4）使用包含变量的字符串连接符如"aa" + s1创建的对象是运行期才创建的,存储在heap中，这样就导致了新的对象在堆中，而字符常量在常量池中，返回false

4.使用String不一定创建对象

在执行到双引号包含字符串的语句时，如String a = "123"，JVM会先到常量池里查找，如果有的话返回常量池里的这个实例的引用，否则的话创建一个新实例并置入常量池里。所以，当我们在使用诸如String str = "abc"；的格式定义对象时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。
只有通过new()方法才能保证每次都创建一个新的对象。

5.使用new String，一定创建对象

在执行String a = new String("123")的时候，首先走常量池的路线取到一个实例的引用，然后在堆上创建一个新的String实例，走以下构造函数给value属性赋值，然后把实例引用赋值给a：

6.关于String.intern()

intern方法使用：一个初始为空的字符串池，它由类String独自维护。当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。

它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。

String.intern(); 
再补充介绍一点：存在于.class文件中的常量池，在运行期间被jvm装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，java查找常量池中是否有相同unicode的字符串常量，
如果有，则返回其引用，如果没有，则在常量池中增加一个unicode等于str的字符串并返回它的引用。

7.关于equals和==

（1）对于==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,double,boolean ），则直接比较其存储的"值"是否相等；如果作用于引用类型的变量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）。

（2）equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。

（3）对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。
其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。

8.String相关的+：

String中的 + 常用于字符串的连接。

显然，通过字节码我们可以得出如下几点结论：
(1).String中使用 + 字符串连接符进行字符串连接时，连接操作最开始时如果都是字符串常量，编译后将尽可能多的直接将字符串常量连接起来，形成新的字符串常量参与后续连接（通过反编译工具jd-gui也可以方便的直接看出）；

(2).接下来的字符串连接是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创建StringBuilder对象，然后依次对右边进行append操作，最后将StringBuilder对象通过toString()方法转换成String对象（注意：中间的多个字符串常量不会自动拼接）。

也就是说String c = "xx" + "yy " + a + "zz" + "mm" + b; 实质上的实现过程是： String c = new StringBuilder("xxyy ").append(a).append("zz").append("mm").append(b).toString();

由此得出结论：当使用+进行多个字符串连接时，实际上是产生了一个StringBuilder对象和一个String对象。